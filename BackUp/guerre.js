// guerre.js — front pour la page Guerres
// - utilise WC.apiFetch (utils.js) si présent
// - fallback: lecture statique /war/state.json et simulation locale pour tests
(function () {
  'use strict';

  // --- Config / state ---
  const API = {
    listWars: '/api/war/list',        // optional endpoint (server)
    declare: '/api/war/declare',      // optional endpoint (server)
    tick: '/api/war/tick',            // optional endpoint (server)
    stateJson: '/war/state.json'      // fallback static file
  };

  const qs = (s, ctx = document) => ctx.querySelector(s);
  const qsa = (s, ctx = document) => Array.from(ctx.querySelectorAll(s));

  let countries = [];       // { id, name, file, continent }
  let countryById = {};     // map id -> name
  let wars = [];            // current wars (from server or local fallback)
  let clientOnlyWars = [];  // wars created locally when API missing

  // utilities (use WC if available)
  const apiFetch = (window.WC && typeof window.WC.apiFetch === 'function') ? window.WC.apiFetch : async (u, o) => {
    try {
      const r = await fetch(u, o);
      const ct = r.headers.get && r.headers.get('content-type') || '';
      const data = (ct.includes('application/json')) ? await r.json() : await r.text();
      if (!r.ok) return { ok: false, status: r.status, data, error: data && data.error ? data.error : `HTTP ${r.status}` };
      return { ok: true, status: r.status, data };
    } catch (err) {
      return { ok: false, status: 0, error: err && err.message ? err.message : 'Network error' };
    }
  };

  const showMsg = (elOrId, text, type = 'info', timeout = 3000) => {
    if (window.WC && typeof window.WC.showMessage === 'function') {
      try { window.WC.showMessage(elOrId || 'toast', text, type, timeout); return; } catch (e) { /* fallback */ }
    }
    const t = document.getElementById('toast');
    if (t) {
      t.textContent = text;
      t.classList.remove('visually-hidden');
      setTimeout(() => { t.classList.add('visually-hidden'); t.textContent = ''; }, timeout);
      return;
    }
    console.log(`[${type}] ${text}`);
  };

  // --- DOM refs ---
  const refs = {};
  function cacheRefs() {
    refs.warList = qs('#warList');
    refs.warDetails = qs('#warDetails');
    refs.declareBtn = qs('#declareBtn');
    refs.refreshBtn = qs('#refreshBtn');
    refs.searchInput = qs('#searchInput');
    refs.toceaseBtn = qs('#toceaseBtn');
  }

  // --- Fetch data ---
  async function loadCountries() {
    // prefer /api/countries
    try {
      const r = await apiFetch('/api/countries', { method: 'GET' });
      if (r && r.ok && r.data && Array.isArray(r.data.countries || r.data)) {
        countries = r.data.countries || r.data;
      } else if (r && r.ok && Array.isArray(r.data)) {
        countries = r.data;
      } else {
        // fallback: try static index generated by server (the server exposes a route /api/countries normally)
        countries = [];
      }
    } catch (e) {
      countries = [];
    }
    // build lookup
    countryById = {};
    for (const c of countries) countryById[c.id] = c.name || c.id;
  }

  async function loadWars() {
    // try API endpoint first
    try {
      const r = await apiFetch(API.listWars, { method: 'GET' });
      if (r && r.ok && r.data && Array.isArray(r.data.wars)) {
        wars = r.data.wars;
        mergeClientWars();
        renderWars();
        return;
      }
    } catch (e) { /* ignore and fallback */ }

    // fallback: try static /war/state.json (served as static asset by your server)
    try {
      const r2 = await fetch(API.stateJson, { cache: 'no-store' });
      if (r2.ok) {
        const payload = await r2.json();
        wars = Array.isArray(payload.wars) ? payload.wars : (payload && payload.wars) || [];
        mergeClientWars();
        renderWars();
        return;
      }
    } catch (e) {
      // final fallback: use clientOnlyWars (empty initially)
      wars = [];
      mergeClientWars();
      renderWars();
    }
  }

  function mergeClientWars() {
    // if the server does not persist client-only wars, keep those visible
    if (clientOnlyWars.length) {
      // avoid duplicating by id
      const existingIds = new Set((wars || []).map(w => w.id));
      for (const cw of clientOnlyWars) {
        if (!existingIds.has(cw.id)) wars.push(cw);
      }
    }
  }

  // --- Render ---
  function renderWars(filter = '') {
    if (!refs.warList) return;
    refs.warList.innerHTML = '';
    const list = (wars || []).filter(w => {
      if (!filter) return true;
      const q = filter.trim().toLowerCase();
      if (w.id && w.id.toLowerCase().includes(q)) return true;
      const names = [...(w.attackers || []), ...(w.defenders || [])].map(id => (countryById[id] || id).toLowerCase());
      return names.some(n => n.includes(q));
    });

    if (!list.length) {
      const el = document.createElement('div');
      el.className = 'empty';
      el.textContent = 'Aucun conflit actif pour l\'instant.';
      refs.warList.appendChild(el);
      return;
    }

    for (const war of list) {
      const item = document.createElement('div');
      item.className = 'war-item';
      item.dataset.warId = war.id;

      const left = document.createElement('div');
      left.className = 'war-meta';

      const attackers = document.createElement('div');
      for (const a of war.attackers || []) {
        const p = document.createElement('div');
        p.className = 'country-pill';
        p.textContent = countryById[a] || a;
        attackers.appendChild(p);
      }

      const vs = document.createElement('div');
      vs.style.fontWeight = 700;
      vs.style.margin = '0 8px';
      vs.textContent = 'VS';

      const defenders = document.createElement('div');
      for (const d of war.defenders || []) {
        const p = document.createElement('div');
        p.className = 'country-pill';
        p.textContent = countryById[d] || d;
        defenders.appendChild(p);
      }

      left.appendChild(attackers);
      left.appendChild(vs);
      left.appendChild(defenders);

      const right = document.createElement('div');
      right.style.display = 'flex';
      right.style.flexDirection = 'column';
      right.style.alignItems = 'flex-end';

      const status = document.createElement('div');
      status.className = `status-badge ${war.status === 'active' ? 'status-active' : 'status-ended'}`;
      status.textContent = war.status === 'active' ? 'Actif' : 'Terminé';

      const meta = document.createElement('div');
      meta.className = 'war-details';
      meta.textContent = `Intensité: ${formatPct(war.intensity || 0)} • Déclaré: ${niceDate(war.startedAt)}`;

      right.appendChild(status);
      right.appendChild(meta);

      item.appendChild(left);
      item.appendChild(right);

      item.addEventListener('click', () => selectWar(war.id));

      refs.warList.appendChild(item);
    }
  }

  function selectWar(warId) {
    const war = (wars || []).find(w => w.id === warId);
    if (!war) return;
    renderWarDetails(war);
    // mark selected in list
    qsa('.war-item').forEach(el => el.classList.toggle('selected', el.dataset.warId === warId));
  }

  function renderWarDetails(war) {
    if (!refs.warDetails) return;
    refs.warDetails.innerHTML = '';

    const title = document.createElement('div');
    title.style.fontWeight = 700;
    title.style.marginBottom = '8px';
    title.textContent = `Conflit — ${war.id}`;

    const sides = document.createElement('div');
    sides.style.display = 'flex';
    sides.style.gap = '8px';
    for (const a of war.attackers || []) {
      const p = document.createElement('div');
      p.className = 'country-pill';
      p.textContent = countryById[a] || a;
      sides.appendChild(p);
    }
    const vs = document.createElement('div'); vs.textContent = 'VS'; vs.style.alignSelf = 'center'; vs.style.fontWeight = 700; sides.appendChild(vs);
    for (const d of war.defenders || []) {
      const p = document.createElement('div');
      p.className = 'country-pill';
      p.textContent = countryById[d] || d;
      sides.appendChild(p);
    }

    const body = document.createElement('div');
    body.className = 'war-details';
    const casualties = JSON.stringify(war.casualties || {});
    body.innerHTML = `
      <div>Statut: <strong>${war.status}</strong></div>
      <div>Intensité: <strong>${formatPct(war.intensity || 0)}</strong></div>
      <div>Pertes: <pre style="display:inline;background:transparent;border:none;padding:0;margin:0">${casualties}</pre></div>
      <div>Début: ${niceDate(war.startedAt)}</div>
      ${war.endedAt ? `<div>Fin: ${niceDate(war.endedAt)}</div>` : ''}
    `;

    refs.warDetails.appendChild(title);
    refs.warDetails.appendChild(sides);
    refs.warDetails.appendChild(body);

    // enable ceasefire button
    if (refs.toceaseBtn) {
      refs.toceaseBtn.disabled = war.status !== 'active';
      refs.toceaseBtn.onclick = () => proposeCeasefire(war.id);
    }
  }

  // --- Declare modal & flow ---
  function openDeclareModal() {
    // modal container
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    const panel = document.createElement('div');
    panel.className = 'panel';
    panel.style.maxWidth = '520px';
    panel.style.margin = '40px auto';
    panel.innerHTML = `
      <h3>Déclarer une guerre</h3>
      <div style="display:flex;gap:8px;margin-top:8px;">
        <label style="flex:1">
          <div class="mini">Attaquant</div>
          <select id="declAtt" style="width:100%;padding:8px;border-radius:8px;border:1px solid #e6e9ef"></select>
        </label>
        <label style="flex:1">
          <div class="mini">Défenseur</div>
          <select id="declDef" style="width:100%;padding:8px;border-radius:8px;border:1px solid #e6e9ef"></select>
        </label>
      </div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end;">
        <button id="declCancel" class="btn">Annuler</button>
        <button id="declConfirm" class="btn btn-primary">Confirmer</button>
      </div>
    `;

    overlay.appendChild(panel);
    document.body.appendChild(overlay);

    // populate selects
    const selA = overlay.querySelector('#declAtt');
    const selD = overlay.querySelector('#declDef');

    // fallback if no countries loaded
    if (!countries.length) {
      const opt = document.createElement('option');
      opt.value = 'unknown';
      opt.textContent = '— Aucun pays disponible —';
      selA.appendChild(opt.cloneNode(true));
      selD.appendChild(opt.cloneNode(true));
    } else {
      for (const c of countries) {
        const a = document.createElement('option');
        a.value = c.id;
        a.textContent = c.name || c.id;
        selA.appendChild(a);

        const b = a.cloneNode(true);
        selD.appendChild(b);
      }
    }

    // handlers
    overlay.querySelector('#declCancel').addEventListener('click', () => { document.body.removeChild(overlay); });
    overlay.querySelector('#declConfirm').addEventListener('click', async () => {
      const attacker = selA.value;
      const defender = selD.value;
      if (!attacker || !defender || attacker === defender) {
        showMsg(null, 'Choisis deux pays différents.', 'error');
        return;
      }
      const btn = overlay.querySelector('#declConfirm');
      if (window.WC && typeof window.WC.setBtnLoading === 'function') window.WC.setBtnLoading(btn, true, 'Déclaration…');
      try {
        const r = await apiFetch(API.declare, { method: 'POST', body: { attacker, defender } });
        if (r && r.ok) {
          showMsg(null, 'Guerre déclarée (API).', 'success');
          // try to refresh from server
          await loadWars();
        } else {
          // server endpoint missing or failed -> create client-only war
          const localWar = createLocalWar(attacker, defender);
          clientOnlyWars.push(localWar);
          wars.push(localWar);
          renderWars(refs.searchInput?.value || '');
          showMsg(null, 'Guerre simulée localement (pas d’endpoint serveur).', 'info');
        }
      } catch (e) {
        const localWar = createLocalWar(attacker, defender);
        clientOnlyWars.push(localWar);
        wars.push(localWar);
        renderWars(refs.searchInput?.value || '');
        showMsg(null, 'Guerre simulée localement (erreur réseau).', 'info');
      } finally {
        if (window.WC && typeof window.WC.setBtnLoading === 'function') window.WC.setBtnLoading(btn, false);
        // close modal
        if (document.body.contains(overlay)) document.body.removeChild(overlay);
      }
    });
  }

  function createLocalWar(attacker, defender) {
    const id = `war_${attacker}_${defender}_${Date.now()}`;
    return {
      id,
      attackers: [attacker],
      defenders: [defender],
      status: 'active',
      startedAt: new Date().toISOString(),
      endedAt: null,
      intensity: 0.12,
      casualties: {},
      economyImpact: {}
    };
  }

  // propose ceasefire (client-side + try server)
  async function proposeCeasefire(warId) {
    // try server endpoint POST /api/war/end (not implemented on server yet)
    try {
      const r = await apiFetch(`/api/war/end`, { method: 'POST', body: { warId } });
      if (r && r.ok) {
        showMsg(null, 'Cessez-le-feu enregistré (API).', 'success');
        await loadWars();
        return;
      }
    } catch (e) { /* ignore */ }

    // fallback: end locally (client-only wars or merge in-memory)
    const w = wars.find(x => x.id === warId);
    if (w) {
      w.status = 'ended';
      w.endedAt = new Date().toISOString();
      renderWars(refs.searchInput?.value || '');
      renderWarDetails(w);
      showMsg(null, 'Cessez-le-feu appliqué localement.', 'info');
    } else {
      showMsg(null, 'Conflit introuvable.', 'error');
    }
  }

  // --- Tick simulation (local) ---
  // This is used when server does not provide a tick endpoint.
  function clientTickOnce() {
    for (const war of wars) {
      if (war.status !== 'active') continue;
      // simple intensity growth
      war.intensity = clampNum((war.intensity || 0) + (Math.random() * 0.04 + 0.01), 0, 1);
      // casualties per side (small)
      const sides = [...(war.attackers || []), ...(war.defenders || [])];
      for (const s of sides) {
        const prev = (war.casualties && war.casualties[s]) ? war.casualties[s] : 0;
        const add = Math.floor((Math.random() * 200) + Math.max(1, (war.intensity || 0) * 100));
        war.casualties = war.casualties || {};
        war.casualties[s] = prev + add;
      }
      // auto-end if intensity too high
      if ((war.intensity || 0) >= 0.95) {
        war.status = 'ended';
        war.endedAt = new Date().toISOString();
      }
    }
    renderWars(refs.searchInput?.value || '');
    // if a war is currently selected, update details
    const sel = qs('.war-item.selected');
    if (sel) {
      const wid = sel.dataset.warId;
      const w = wars.find(x => x.id === wid);
      if (w) renderWarDetails(w);
    }
  }

  // --- Helpers ---
  function niceDate(iso) {
    if (!iso) return '—';
    try {
      const d = new Date(iso);
      return d.toLocaleString();
    } catch (e) { return iso; }
  }
  function formatPct(v) {
    return `${Math.round((v || 0) * 100)}%`;
  }
  function clampNum(v, a, b) { return Math.max(a, Math.min(b, v)); }

  // --- Wire UI events ---
  function wire() {
    if (refs.declareBtn) refs.declareBtn.addEventListener('click', openDeclareModal);
    if (refs.refreshBtn) refs.refreshBtn.addEventListener('click', async () => {
      // try server tick first
      try {
        const r = await apiFetch(API.tick, { method: 'POST' });
        if (r && r.ok) {
          showMsg(null, 'Tick appliqué (API).', 'success');
          await loadWars();
          return;
        }
      } catch (e) { /* fall through to local tick */ }

      // fallback local tick:
      clientTickOnce();
      showMsg(null, 'Tick appliqué localement.', 'info');
    });

    if (refs.searchInput) {
      refs.searchInput.addEventListener('input', (e) => {
        renderWars(e.target.value || '');
      });
    }
  }

  // --- Init ---
  async function init() {
    cacheRefs();
    await loadCountries();
    await loadWars();
    wire();
  }

  // run
  document.addEventListener('DOMContentLoaded', init);
})();
